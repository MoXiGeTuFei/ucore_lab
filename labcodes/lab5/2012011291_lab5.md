#LAB5 实验报告


##【练习1】加载应用程序并执行（需要编码）
	do_execv函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，
建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，
确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。
```
1.实现思路
答：代码如下
   tf->tf_cs=USER_CS;
   tf->tf_ds=tf->tf_es=tf->tf_ss=USER_DS;
   tf->tf_esp=USTACKTOP;
   tf->tf_eip=elf->e_entry;
   tf->tf_eflags=FL_IF;
2.请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。
(即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过)
答：
	该进程标记为runnable后，被schedule函数找到，然后调用proc_run()让他跑起来。这个proc_run()首先完成了页目录表切换（lcr3(next->cr3)，
这样就把页目录表地址变为了用户进程的页目录表）、内核栈的切换等工作之后（load_esp0(next->kstack + KSTACKSIZE)），调用switch_to函数进行上下文切换。
在kern/process/switch.S中定义的switch_to函数，首先将当前的寄存器信息保存至被替换者的context中，又用替换者的context将寄存器替换掉，这样就完成了上下文切换。
这时，eip已经被更换，新进程可以执行。
```


##【练习2】父进程复制自己的内存空间给子进程（需要编码）
	创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。
具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。
```
1.实现思路
答：
		void* src_kvaddr=page2kva(page);	//找到父进程该页的kernal virtual address
        void* dst_kvaddr=page2kva(npage);	//找到子进程该页的kernal virtual address
        memcpy(dst_kvaddr,src_kvaddr,PGSIZE); //将父进程页内容拷贝到子进程
        ret=page_insert(to, npage, start, perm);	//参数依次为：子进程的页目录表，要映射的页（子进程新建的页），要映射的线性地址，标识
													//实际完成了子进程线性地址(start)到物理地址(page的phyaddr)的映射
        assert(ret == 0);							
2.请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。
答：
	Copy-on-write主要是指如果有多个使用者对同一内存A进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。
若某使用者需要对这个资源A进行写操作，则系统再对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝资源B。
	所以，在do_fork产生子进程时将参数clone_flags改为share，这样在其调用copy_mm函数时子进程将共享父进程内存。然后，进行一些设置：
对应页表项为只读，对应物理页设置reference_counter对映射到它上面的进程数进行计数。当子进程只读时，直接返回相应的指针。
当子进程写时，产生异常，申请一片新的内存然后复制父进程物理页，修改子进程页表项，然后这块内存就可以写了。
```


##【练习3】 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
```
1.请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。
答：
fork由do_fork实现:
1.调用alloc_proc,分配一个进程控制块TCB；
2.调用setup_stack，给该进程分配一个内核栈；
3.调用copy_mm，复制或共享父进程内存管理结构；
4.调用copy_thread，设置中断帧和执行上下文，保证子进程正常执行；
5.调用get_pid，分配一个pid；
6.将TCB塞入链表和hash表中；
7.调用wakeup_proc，将进程状态设置为“就绪”；
8.返回子进程id。

exec由do_execve和load_icode实现:
1.首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。
2.接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。
3.执行中断返回指令“iret”后，将切换到用户进程的第一条语句位置处开始执行。

wait由函数do_wait实现:
1. 如果pid!=0，表示只找一个进程id号为pid的退出状态的子进程，否则找任意一个处于退出状态的子进程；
2. 如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为PROC_SLEEPING，
睡眠原因为WT_CHILD（即等待子进程退出），调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤1处执行；
3. 如果此子进程的执行状态为PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作，
即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，
消除了它所占用的所有资源。

exit由由函数do_exit实现:
首先，exit函数会把一个退出码error_code传递给ucore，ucore通过执行内核函数do_exit来完成对当前进程的退出处理，主要工作简单地说就是回收当前进程所占的大部分内存资源，并通知父进程完成最后的回收工作，具体流程如下：
1. 如果current->mm != NULL，表示是用户进程，则开始回收此用户进程所占用的用户态虚拟内存空间；
	a) 首先执行“lcr3(boot_cr3)”，切换到内核态的页表上，这样当前用户进程目前只能在内核虚拟地址空间执行了，这是为了确保后续释放用户态内存和进程页表的工作能够正常执行；
	b) 如果当前进程控制块的成员变量mm的成员变量mm_count减1后为0（表明这个mm没有再被其他进程共享，可以彻底释放进程所占的用户虚拟空间了。），则开始回收用户进程所占的内存资源：
		i. 调用exit_mmap函数释放current->mm->vma链表中每个vma描述的进程合法空间中实际分配的内存，然后把对应的页表项内容清空，最后还把页表所占用的空间释放并把对应的页目录表项清空；
		ii. 调用put_pgdir函数释放当前进程的页目录所占的内存；
		iii. 调用mm_destroy函数释放mm中的vma所占内存，最后释放mm所占内存；
	c) 此时设置current->mm为NULL，表示与当前进程相关的用户虚拟内存空间和对应的内存管理成员变量所占的内核虚拟内存空间已经回收完毕；
2. 这时，设置当前进程的执行状态current->state=PROC_ZOMBIE，当前进程的退出码current->exit_code=error_code。此时当前进程已经不能被调度了，需要此进程的父进程来做最后的回收工作（即回收描述此进程的内核栈和进程控制块）；
3. 如果当前进程的父进程current->parent处于等待子进程状态：current->parent->wait_state==WT_CHILD，
则唤醒父进程（即执行“wakup_proc(current->parent)”），让父进程帮助自己完成最后的资源回收；
4. 如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程initproc，且各个子进程指针需要插入到initproc的子进程链表中。如果某个子进程的执行状态是PROC_ZOMBIE，则需要唤醒initproc来完成对此子进程的最后回收工作。
5. 执行schedule()函数，选择新的进程执行。

系统调用的实现：
1.初始化系统调用对应的中断描述符
在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表，并设置一个特定中断号的中断门，专门用于用户进程访问系统调用。此事由ide_init函数完成。
2.建立系统调用的用户库准备
在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后，还需在用户态的应用程序中初始化好相关工作，简化应用程序访问系统调用的复杂性。为此在用户态建立了一个中间层，即简化的libc实现，
在user/libs/ulib.[ch]和user/libs/syscall.[ch]中完成了对访问系统调用的封装。用户态最终的访问系统调用函数是syscall
3.系统调用的执行
    (1)遇到指令INT T_SYSCALL时CPU根据中断描述符转入内核态，开始了系统调用执行过程。
    (2)软件进一步保存执行系统调用前的执行现场，把相关内容保存到当前进程的中断帧trapframe中。
    (3)完成具体系统调用服务。
    (4)按调用关系的路径原路返回到__alltraps中，操作系统开始根据中断帧内容恢复现场。
    (5)执行IRET，返回用户态，把EIP指向tf_eip的值，继续执行用户程序。

2.请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？
答：
fork：从父进程复制子进程。会将子进程RUNNABLE状态。（ucore中没有ready，直接就是runnable）
exec：将子进程代码复制到父进程空间。不影响执行状态。
wait：将状态变成SLEEPING。
exit：将执行状态变为成ZOMBIE，表示该进程已经结束，等待资源回收。
更详细的转换关系见下一题的调用图。

3.请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）
答：
process state changing:
                                            
  alloc_proc                                 RUNNING
      +                                   +--<----<--+
      +                                   + proc_run +
      V                                   +-->---->--+ 
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                           A      +                                                           +
                                           |      +--- do_exit --> PROC_ZOMBIE                                +
                                           +                                                                  + 
                                           -----------------------wakeup_proc----------------------------------
```

##【其他】
```
1.说明你的实现与参考答案的区别
答:
	2个函数都是自己独立完成。但是注释写的十分仔细，所以最后与答案对照发现没有什么不同。

2.列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解。
答：
	对应了进程的创建（fork）、执行（exec）、挂起（wait）、退出（exit），还有特权级的转换，系统调用的实现。
3.列出你认为OS原理中很重要，但在实验中没有对应上的知识点
答：
	进程的状态转换比较简单，比原理课上讲的简化很多。调度算法方面只用了简单的FCFS，课堂上讲的很多更高效的算法没有对应上。
```





